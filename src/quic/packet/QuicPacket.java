package quic.packet;

import quic.exception.QuicException;
import quic.frame.QuicFrame;
import quic.util.Util;

import java.io.IOException;
import java.io.Serializable;
import java.nio.ByteBuffer;
import java.util.*;

/**
 * Represents IETF-QUIC Packet
 * Chapter 12.3
 *
 * @version 1.2
 */
public abstract class QuicPacket {

    private static int dcIdSize = 0;

    /**
     * The Destination Connection ID field follows the DCID Len and is between 0 and 20 bytes in length.
     */
    private byte[] dcID;

    /**
     * This number is used in determining the cryptographic nonce for packet protection.
     * Each endpoint maintains a separate packet number for sending and receiving.
     */
    private long packetNumber;

    /**
     * List of frames included in each packet
     */
    private Set<QuicFrame> frames = new HashSet<>();

    /**
     * Value constructor for packet.QuicPacket
     *
     * @param dcID         Destination Connection ID
     * @param packetNumber Number of this packet generated by the endpoint
     */
    public QuicPacket(byte[] dcID, long packetNumber, Set<QuicFrame> frames) {
        this.setDcID(dcID);
        this.setPacketNumber(packetNumber);
        this.setDcIdSize(dcID.length);
        if(frames==null){
            throw new NullPointerException();
        }
        if(frames!=null && frames.size()==0){
            throw new IllegalArgumentException();
        }
        if (frames != null) {
            for (QuicFrame x : frames) {
                this.addFrame(x);
            }
        }
    }

    public static int getDcIdSize() {
        return dcIdSize;
    }

    public static void setDcIdSize(int dcIdSize) {
        QuicPacket.dcIdSize = dcIdSize;
    }

    /**
     * Encodes a packet into byte array
     *
     * @return byte[]
     */
    public byte[] encode() {
        return new byte[3];
    }

    /**
     * Decodes byte array into packet object. The destination connection ID
     * size is used when the connection has already negotiated the size of the
     * ID.
     *
     * @param arr      the array of bytes to decode
     * @param dcIdSize the destination connection ID size
     * @return the parsed packet
     */

    public static QuicPacket decode(byte[] arr, int dcIdSize) throws QuicException {
        return Util.quicShortHeaderDecoder(arr,dcIdSize);
    }

    public static QuicPacket specialDecode(byte[] arr) throws QuicException{
        int headerArry[] = new int[8];
        int headerByte=0;
        try {
            headerByte = (int) arr[0];
            if (headerByte < 0) {
                headerByte += 256;
            }

            for (int c = 7; c >= 0; c--) {
                int x = (int) Math.pow(2, c);
                if ((x & headerByte) == 0) {
                    headerArry[7 - c] = 0;
                } else {
                    headerArry[7 - c] = 1;
                }
            }
        }catch (Exception e){
            throw new QuicException(10,0,"Header Byte Exception");
        }
        if (headerArry[0] == 0) {
            //shortheader
            return decode(arr,getDcIdSize());
        } else if (headerArry[0] == 1) {                          //Long header
            if (headerArry[2] == 0 && headerArry[3] == 0) {
                //intialpacket
                System.out.println("Initial packet recieved");
                System.out.println("headerByte = " + headerByte);
                return Util.specialQuicInitialPacketDecorder(arr,headerByte,headerArry);
            } else if (headerArry[2] == 0 && headerArry[3] == 1) {
                //0-RTT
                System.out.println("0-RTT packet recieved");
                System.out.println("headerByte = " + headerByte);
                return Util.specialQuicLongHeaderPacketDecorder(1, arr, headerByte, headerArry);
            } else if (headerArry[2] == 1 && headerArry[3] == 0) {
                //handshake
                System.out.println("Handshake packet recieved");
                System.out.println("headerByte = " + headerByte);
                return Util.specialQuicLongHeaderPacketDecorder(2, arr, headerByte, headerArry);

            } else {
                throw new QuicException(0, 0, "header byte invalid");
            }

        }
        throw new QuicException(0,0,"invalid data");
    }

    /**
     * Decodes byte array into packet object
     *
     * @param arr array of bytes of some packet
     * @return packet.QuicPacket
     */

    public static QuicPacket decode(byte[] arr) throws QuicException {
        int headerArry[] = new int[8];
        int headerByte;
        try {
            System.out.println("---------------------------------------");
            headerByte = (int) arr[0];
            if (headerByte < 0) {
                headerByte += 256;
            }
            if (headerByte < 64) {
                throw new QuicException(10, 0, "Invalid header byte");
            }
            if((headerByte & 12) != 0){
                throw new QuicException(10, 0, "Invalid header byte");
            }
            if((headerByte & 64) ==0){
                throw new QuicException(10, 0, "Invalid header byte");
            }
            for (int c = 7; c >= 0; c--) {
                int x = (int) Math.pow(2, c);
                if ((x & headerByte) == 0) {
                    headerArry[7 - c] = 0;
                } else {
                    headerArry[7 - c] = 1;
                }
            }
            System.out.println("headerByte = " + headerByte);
        } catch (Exception e) {
            throw new QuicException(10, 0, "invalid header byte");
        }
        if (headerArry[0] == 0) {
            //shortheader
            return decode(arr,getDcIdSize());
        } else if (headerArry[0] == 1) {                          //Long header
            if (headerArry[2] == 0 && headerArry[3] == 0) {
                //intialpacket
                return Util.quicIntialPacketDecoder(0, arr, headerByte, headerArry);
            } else if (headerArry[2] == 0 && headerArry[3] == 1) {
                //0-RTT
                return Util.quicLongHeaderPacketDecoder(1, arr, headerByte, headerArry);
            } else if (headerArry[2] == 1 && headerArry[3] == 0) {
                //handshake
                return Util.quicLongHeaderPacketDecoder(2, arr, headerByte, headerArry);

            } else {
                throw new QuicException(0, 0, "header byte invalid");
            }

        }
        throw new QuicException(0,0,"invalid data");
    }

    /**
     * Get destination connection id
     *
     * @return dcId
     */
    public byte[] getDcID() {
        return dcID;
    }

    /**
     * Set destination connection id
     *
     * @param dcID destination connection id
     */
    public void setDcID(byte[] dcID) {

        if (dcID != null && dcID.length <= 20) {
            this.dcID = dcID;
        } else if (dcID == null) {
            throw new NullPointerException();
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * Retrieves packet number
     *
     * @return packet number
     */
    public long getPacketNumber() {
        return packetNumber;
    }

    /**
     * Sets packet number
     *
     * @param packetNumber number of the packet
     */
    public void setPacketNumber(long packetNumber) {
        if (packetNumber >= 0L && packetNumber < Math.pow(2,32)) {
            this.packetNumber = packetNumber;
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * Gets the IETF-QUIC frames
     *
     * @return frames associated with this packet
     */
    public Set<QuicFrame> getFrames() {
        Set<QuicFrame> temp = new HashSet<>();
        Iterator<QuicFrame> iterator = frames.iterator();
        while (iterator.hasNext()) {
            QuicFrame f = iterator.next();
            temp.add(f);
        }
        frames.removeAll(temp);
        return temp;
    }
    public Set<QuicFrame> showFrames(){
        return frames;
    }

    /**
     * Adds a frame to  this packet
     *
     * @param frame the frame to add
     */
    public void addFrame(QuicFrame frame) {
        this.frames.add(frame);

    }



    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof QuicPacket)) return false;
        QuicPacket that = (QuicPacket) o;
        return getPacketNumber() == that.getPacketNumber() &&
                Arrays.equals(getDcID(), that.getDcID());
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(getPacketNumber());
        result = 31 * result + Arrays.hashCode(getDcID());
        return result;
    }
}

