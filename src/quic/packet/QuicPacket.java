package quic.packet;

import quic.exception.QuicException;
import quic.frame.QuicFrame;
import quic.util.Util;

import java.io.IOException;
import java.io.Serializable;
import java.util.*;

/**
 * Represents IETF-QUIC Packet
 * Chapter 12.3
 *
 * @version 1.2
 */
public abstract class QuicPacket {

    /**
     * The Destination Connection ID field follows the DCID Len and is between 0 and 20 bytes in length.
     */
    private byte[] dcID;

    /**
     * This number is used in determining the cryptographic nonce for packet protection.
     * Each endpoint maintains a separate packet number for sending and receiving.
     */
    private long packetNumber;

    /**
     * List of frames included in each packet
     */
    private Set<QuicFrame> frames = new HashSet<>();

    /**
     * Value constructor for packet.QuicPacket
     *
     * @param dcID         Destination Connection ID
     * @param packetNumber Number of this packet generated by the endpoint
     */
    public QuicPacket(byte[] dcID, long packetNumber) {
        this.setDcID(dcID);
        this.setPacketNumber(packetNumber);
    }

    /**
     * Encodes a packet into byte array
     *
     * @return byte[]
     */
    public byte[] encode() {
        return new byte[3];
    }

    /**
     * Decodes byte array into packet object. The destination connection ID
     * size is used when the connection has already negotiated the size of the
     * ID.
     *
     * @param arr      the array of bytes to decode
     * @param dcIdSize the destination connection ID size
     * @return the parsed packet
     */

    public static QuicPacket decode(byte[] arr, int dcIdSize) throws QuicException {
        return null;
    }

    /**
     * Decodes byte array into packet object
     *
     * @param arr array of bytes of some packet
     * @return packet.QuicPacket
     */

    public static QuicPacket decode(byte[] arr) throws QuicException {
        int headerArry[] = new int[8];
        int headerByte;
        try {
            System.out.println("---------------------------------------");
            headerByte = (int) arr[0];
            if (headerByte < 0) {
                headerByte += 256;
            }
            if (headerByte < 64) {
                throw new QuicException(0, 0, "Invalid header byte");
            }
            for (int c = 7; c >= 0; c--) {
                int x = (int) Math.pow(2, c);
                if ((x & headerByte) == 0) {
                    headerArry[7 - c] = 0;
                } else {
                    headerArry[7 - c] = 1;
                }
            }
            System.out.println("headerByte = " + headerByte);
        } catch (Exception e) {
            throw new QuicException(0, 0, "invalid input");
        }
        //System.out.println(headerArry[2]+" "+headerArry[3]);
        if (headerArry[0] == 0) {
            //shortheader
        } else if (headerArry[0] == 1) {                          //Long header
            if (headerArry[2] == 0 && headerArry[3] == 0) {
                //intialpacket
                return quicIntialPacketDecoder(0, arr, headerByte, headerArry);
            } else if (headerArry[2] == 0 && headerArry[3] == 1) {
                //0-RTT
                return quicLongHeaderPacketDecoder(1, arr, headerByte, headerArry);
            } else if (headerArry[2] == 1 && headerArry[3] == 0) {
                //handshake
                return quicLongHeaderPacketDecoder(2, arr, headerByte, headerArry);

            } else {
                throw new QuicException(0, 0, "header byte invalid");
            }

        }
        throw new QuicException(0,0,"invalid data");
    }

    /**
     * Get destination connection id
     *
     * @return dcId
     */
    public byte[] getDcID() {
        return dcID;
    }

    /**
     * Set destination connection id
     *
     * @param dcID destination connection id
     */
    public void setDcID(byte[] dcID) {

        if (dcID != null && dcID.length <= 20) {
            this.dcID = dcID;
        } else if (dcID == null) {
            throw new NullPointerException();
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * Retrieves packet number
     *
     * @return packet number
     */
    public long getPacketNumber() {
        return packetNumber;
    }

    /**
     * Sets packet number
     *
     * @param packetNumber number of the packet
     */
    public void setPacketNumber(long packetNumber) {
        if (packetNumber >= 0L) {
            this.packetNumber = packetNumber;
        } else {
            throw new IllegalArgumentException();
        }
    }

    /**
     * Gets the IETF-QUIC frames
     *
     * @return frames associated with this packet
     */
    public Set<QuicFrame> getFrames() {
        Set<QuicFrame> temp = new HashSet<>();
        Iterator<QuicFrame> iterator = frames.iterator();
        while (iterator.hasNext()) {
            QuicFrame f = iterator.next();
            temp.add(f);
        }
        frames.removeAll(temp);
        return temp;
    }
    public Set<QuicFrame> showFrames(){
        return frames;
    }

    /**
     * Adds a frame to  this packet
     *
     * @param frame the frame to add
     */
    public void addFrame(QuicFrame frame) {
        this.frames.add(frame);

    }

    public static QuicPacket quicIntialPacketDecoder(int type, byte[] arr, int headerByte, int headerArry[]) {
        int p = 1;
        byte[] version_arr = new byte[4];
        int n = p;
        for (; n < p + 4; n++) {
            version_arr[n - p] = arr[n];
        }
        long version = Util.variableLengthInteger(version_arr, 0);
        System.out.println("version = " + version);
        p = n;
        ////////////////////////////
        int dcIdLenD = (int) arr[p];
        System.out.println("dcidlen = " + dcIdLenD);
        p++;
        byte[] dcIdD = new byte[dcIdLenD];
        int i = p;
        for (; i < p + dcIdLenD; i++) {
            dcIdD[i - p] = arr[i];
        }
        System.out.print("dcId = ");
        for (byte x : dcIdD) {
            System.out.print(Util.byteToHex(x) + " ");
        }
        System.out.println();
        p = i;
        ///////////////////////////
        int scIdLenD = (int) arr[p];
        System.out.println("scidlen = " + scIdLenD);
        p++;
        byte[] scIdD = new byte[scIdLenD];
        int j = p;
        for (; j < p + scIdLenD; j++) {
            scIdD[j - p] = arr[j];
        }
        System.out.print("scId = ");
        for (byte x : scIdD) {
            System.out.print(Util.byteToHex(x) + " ");
        }
        System.out.println();
        p = j;
        ////////////////////////////
        int tokenLengthLen = Util.variableLengthIntegerLength(arr[p]);
        byte[] tokenLength_arr = new byte[tokenLengthLen];
        for (int c = p; c < p + tokenLengthLen; c++) {
            tokenLength_arr[c - p] = arr[c];
        }
        p += tokenLengthLen;
        long tokenLength = Util.variableLengthInteger(tokenLength_arr, 1);
        System.out.println("Token length = " + tokenLength);

        byte[] token = new byte[(int) tokenLength];
        for (int c = p; c < p + tokenLength; c++) {
            token[c - p] = arr[c];
        }
        p += tokenLength;
        ////////////////////////////
        int lengthSize = Util.variableLengthIntegerLength(arr[p]);
        byte[] len_arr = new byte[lengthSize];
        for (int c = p; c < lengthSize + p; c++) {
            len_arr[c - p] = arr[c];
        }
        p += lengthSize;
        long length = Util.variableLengthInteger(len_arr, 1);
        System.out.println("length = " + length);
        ///////////////////////////////////////
        int packetNoLen = (headerByte & 3) + 1;

        byte[] packNum_arr = new byte[packetNoLen];
        for (int c = p; c < packetNoLen + p; c++) {
            packNum_arr[c - p] = arr[c];
        }
        p += packetNoLen;
        long packetNum = Util.variableLengthInteger(packNum_arr, 0);
        System.out.println("packetNumber = " + packetNum);
        /////////
        byte[] frameSetD = new byte[(int) (length - packetNoLen)];
        int k = p;

        for (; k < p + (length - (packetNoLen)); k++) {
            frameSetD[k - p] = arr[k];
            System.out.print(k + " ");
        }
        p=k;
        Set<QuicFrame>temp = new HashSet<>();
        try {
            temp.add(QuicFrame.decode(frameSetD));
        } catch (QuicException e) {
            e.printStackTrace();
        }
        if (type == 0) {
            QuicPacket initialPacket = new QuicInitialPacket(dcIdD, packetNum, version, scIdD,temp);
            return initialPacket;
        }

        return null;
    }

    public static QuicPacket quicLongHeaderPacketDecoder(int type, byte[] arr, int headerByte, int headerArry[]) {
        int p = 1;
        byte[] version_arr = new byte[4];
        int n = p;
        for (; n < p + 4; n++) {
            version_arr[n - p] = arr[n];
        }
        long version = Util.variableLengthInteger(version_arr, 0) ;
        System.out.println("version = " + version);
        p = n;
        ////////////////////////////
        int dcIdLenD = (int) arr[p];
        System.out.println("dcidlen = " + dcIdLenD);
        p++;
        byte[] dcIdD = new byte[dcIdLenD];
        int i = p;
        for (; i < p + dcIdLenD; i++) {
            dcIdD[i - p] = arr[i];
        }
        System.out.print("dcId = ");
        for (byte x : dcIdD) {
            System.out.print(Util.byteToHex(x) + " ");
        }
        System.out.println();
        p = i;
        ///////////////////////////
        int scIdLenD = (int) arr[p];
        System.out.println("scidlen = " + scIdLenD);
        p++;
        byte[] scIdD = new byte[scIdLenD];
        int j = p;
        for (; j < p + scIdLenD; j++) {
            scIdD[j - p] = arr[j];
        }
        System.out.print("scId = ");
        for (byte x : scIdD) {
            System.out.print(Util.byteToHex(x) + " ");
        }
        System.out.println();
        p = j;
        ////////////////////////////
        int lengthSize = Util.variableLengthIntegerLength(arr[p]);
        byte[] len_arr = new byte[lengthSize];
        for (int c = p; c < lengthSize + p; c++) {
            len_arr[c - p] = arr[c];
        }
        p += lengthSize;
        long length = Util.variableLengthInteger(len_arr, 1);
        System.out.println("length = " + length);
        ///////////////////////////////////////
        int packetNoLen = (headerByte & 3) + 1;

        byte[] packNum_arr = new byte[packetNoLen];
        for (int c = p; c < packetNoLen + p; c++) {
            packNum_arr[c - p] = arr[c];
        }
        p += packetNoLen;
        long packetNum = Util.variableLengthInteger(packNum_arr, 0);
        System.out.println("packetNumber = " + packetNum);
        /////////
        byte[] frameSetD = new byte[(int) (length - packetNoLen)];
        int k = p;

        for (; k < p + (length - (packetNoLen)); k++) {
            frameSetD[k - p] = arr[k];
            System.out.print(k + " ");
        }
        p = k;
        Set<QuicFrame>temp = new HashSet<>();
        try {
            temp.add(QuicFrame.decode(frameSetD));
        } catch (QuicException e) {
            e.printStackTrace();
        }
        if (type == 1) {
            QuicPacket zeroRttPacket = new QuicZeroRTTPacket(dcIdD, packetNum, version, scIdD, temp);
            return zeroRttPacket;
        } else if (type == 2) {
            return new QuicHandshakePacket(dcIdD, packetNum, version, scIdD, temp);
        }

        return null;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof QuicPacket)) return false;
        QuicPacket that = (QuicPacket) o;
        return getPacketNumber() == that.getPacketNumber() &&
                Arrays.equals(getDcID(), that.getDcID());
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(getPacketNumber());
        result = 31 * result + Arrays.hashCode(getDcID());
        return result;
    }
}

